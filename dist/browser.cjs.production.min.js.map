{"version":3,"file":"browser.cjs.production.min.js","sources":["../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/constants.ts","../src/offline.ts","../src/socket.ts","../src/ListenerManager.ts","../src/socketauth.ts","../src/doc-client.ts","../src/presence-client.ts","../src/room-client.ts","../src/authorize.ts","../src/client.ts"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","export const ROOM_SERICE_CLIENT_URL = 'https://aws.roomservice.dev';\n","/**\n * A wrapper around idb-keyval to make the\n * \"set\" and \"get\" functions more explicit and\n * readable.\n */\n\nimport { get, set } from 'idb-keyval';\nimport uuid from 'uuid/v4';\nimport invariant from 'invariant';\n\ninterface IOffline {\n  getDoc: (roomRef: string, docId: string) => Promise<string>;\n  setDoc: (roomRef: string, docId: string, value: string) => Promise<any>;\n  getOrCreateActor: () => Promise<string | null>;\n}\n\nconst Offline: IOffline = {\n  getDoc: async (roomRef, docId) => {\n    try {\n      return await get('rs:' + roomRef + '/' + docId);\n    } catch (err) {\n      console.warn(\n        \"Something went wrong getting Room Service's state offline\",\n        err\n      );\n      return '';\n    }\n  },\n  setDoc: async (roomRef, docId, value) => {\n    try {\n      await set('rs:' + roomRef + '/' + docId, value);\n    } catch (err) {\n      console.warn(\n        \"Something went wrong saving Room Service's state offline\",\n        err\n      );\n    }\n  },\n  getOrCreateActor: async () => {\n    invariant(\n      typeof window !== 'undefined',\n      \"getOrCreateActor was used on the server side; this is a bug in the client, if you're seeing this, let us know.\"\n    );\n\n    try {\n      const actor = await get('rs:actor');\n      if (actor) {\n        return actor as string;\n      }\n\n      const id = uuid();\n      set('rs:actor', id);\n      return id;\n    } catch (err) {\n      console.warn('Cant use offline mode in this environment, skipping.');\n      return null;\n    }\n  },\n};\n\nexport default Offline;\n","/**\n * This is just a wrapper around Socket.io that's easier\n * to test.\n */\nimport IO from 'socket.io-client';\nimport invariant from 'invariant';\n\nexport type Events =\n  | 'connect'\n  | 'disconnect'\n  | 'error'\n  | 'sync_room_state'\n  | 'update_presence'\n  | 'authenticated'\n  | 'reconnect_attempt';\n\n// Namespaced so we can mock stuff\nconst Sockets = {\n  newSocket(url: string, opts?: SocketIOClient.ConnectOpts) {\n    return IO(url, opts);\n  },\n\n  on(\n    socket: SocketIOClient.Socket,\n    event: Events,\n    fn: (...args: any[]) => void\n  ) {\n    invariant(!!socket && !!event, 'Requires socket defined');\n    socket.on(event, fn);\n  },\n\n  off(\n    socket: SocketIOClient.Socket,\n    event: Events,\n    callback?: (...args: any[]) => void\n  ) {\n    socket.off(event, callback);\n  },\n\n  emit(\n    socket: SocketIOClient.Socket,\n    event: 'sync_room_state' | 'update_presence' | 'authenticate',\n    ...args: any[]\n  ) {\n    invariant(!!socket && !!event, 'Requires socket defined');\n    socket.emit(event, ...args);\n  },\n\n  disconnect(socket: SocketIOClient.Socket) {\n    socket.disconnect();\n  },\n};\n\nexport default Sockets;\n","import Sockets, { Events } from './socket';\n\ninterface Listener {\n  event: Events;\n  callback: (...args: any[]) => void;\n}\n\n// Tracks which listeners are added, and can remove them\nexport default class ListenerManager {\n  private _listeners: Listener[] = [];\n\n  on(\n    socket: SocketIOClient.Socket,\n    event: Events,\n    callback: (...args: any[]) => void\n  ) {\n    this._listeners.push({ event, callback });\n    Sockets.on(socket, event, callback);\n  }\n\n  removeAllListeners(socket: SocketIOClient.Socket) {\n    this._listeners.forEach(listener => {\n      Sockets.off(socket, listener.event, listener.callback);\n    });\n    this._listeners = [];\n  }\n}\n","import Sockets from './socket';\nimport invariant from 'invariant';\nimport ListenerManager from './ListenerManager';\n\nexport async function authorizeSocket(\n  socket: SocketIOClient.Socket,\n  token: string,\n  roomId: string\n): Promise<boolean | undefined> {\n  return new Promise(resolve => {\n    invariant(socket, 'Requires socket to be defined');\n\n    const listenerManager = new ListenerManager();\n\n    const timeout = setTimeout(() => {\n      resolve(false);\n      listenerManager.removeAllListeners(socket);\n    }, 15000);\n\n    Sockets.emit(socket, 'authenticate', {\n      meta: {\n        roomId,\n      },\n      payload: token,\n    });\n\n    listenerManager.on(socket, 'authenticated', () => {\n      clearTimeout(timeout);\n      resolve(true);\n      listenerManager.removeAllListeners(socket);\n    });\n\n    listenerManager.on(socket, 'disconnect', () => {\n      resolve();\n      clearTimeout(timeout);\n      listenerManager.removeAllListeners(socket);\n    });\n  });\n}\n","import Automerge, { Doc, load, merge, save } from 'automerge';\nimport { Map } from 'immutable';\nimport invariant from 'invariant';\nimport { debounce } from 'lodash';\nimport { Peer } from 'manymerge';\nimport { Message } from 'manymerge/dist/types';\nimport safeJsonStringify from 'safe-json-stringify';\nimport { ROOM_SERICE_CLIENT_URL } from './constants';\nimport Offline from './offline';\nimport Sockets from './socket';\nimport { Obj, Room, Session } from './types';\nimport { authorizeSocket } from './socketauth';\nimport ListenerManager from './ListenerManager';\n\nconst DOC_NAMESPACE = '/v1/doc';\n\ninterface RoomPacket {\n  meta: {\n    roomId: string;\n  };\n  payload: {\n    msg: Message;\n  };\n}\n\nfunction asRoomStr(room: RoomPacket) {\n  return safeJsonStringify(room);\n}\n\nexport default class DocClient<T extends Obj> {\n  private readonly _peer: Peer;\n  private readonly _roomReference: string;\n  private _socket?: SocketIOClient.Socket;\n  private _roomId?: string;\n  private _doc?: Doc<T>;\n  private _actorId?: string | null;\n  private _defaultDoc?: T;\n  private _authorized?: Promise<boolean | undefined>;\n  private _listenerManager: ListenerManager;\n\n  // We define this as a local variable to make testing easier\n  _socketURL: string;\n\n  private _onUpdateSocketCallback?: (data: string) => any;\n  private _onConnectSocketCallback?: () => any;\n  private _onDisconnectSocketCallback?: () => any;\n\n  private _saveOffline: (docId: string, doc: Doc<T>) => void;\n\n  constructor(parameters: { roomReference: string; defaultDoc?: T }) {\n    this._roomReference = parameters.roomReference;\n    this._defaultDoc = parameters.defaultDoc;\n    this._peer = new Peer(this._sendMsgToSocket);\n    this._socketURL = ROOM_SERICE_CLIENT_URL;\n    this._listenerManager = new ListenerManager();\n\n    // We define this here so we can debounce the save function\n    // Otherwise we'll get quite the performance hit\n    let saveOffline = (docId: string, doc: Doc<T>) => {\n      Offline.setDoc(this._roomReference, docId, save(doc));\n    };\n    this._saveOffline = debounce(saveOffline, 120);\n  }\n\n  private async readActorIdThenCreateDoc(state?: T) {\n    const actorId = await Offline.getOrCreateActor();\n    this._actorId = actorId;\n\n    return this.createDoc(actorId, state);\n  }\n\n  private createDoc(actorId: string | null, state?: T) {\n    if (this._doc) {\n      return this._doc;\n    }\n\n    const params = actorId ? { actorId } : undefined;\n    const defaultDoc = Automerge.from(state || ({} as T), params);\n\n    // Automerge technically supports sending multiple docs\n    // over the wire at the same time, but for simplicity's sake\n    // we just use one doc at for the moment.\n    //\n    // In the future, we may support multiple documents per room.\n    this._doc = defaultDoc;\n    this._peer.notify(this._doc);\n\n    return this._doc;\n  }\n\n  /**\n   * Manually attempt to restore the state from offline storage.\n   */\n  async restore(): Promise<any> {\n    // We can't restore on the server, or in environments\n    // where indexedb is not defined\n    if (typeof window === 'undefined' || typeof indexedDB === 'undefined') {\n      return {};\n    }\n\n    if (!this._doc) {\n      await this.readActorIdThenCreateDoc(this._defaultDoc);\n    }\n    return this.syncOfflineCache();\n  }\n\n  /**\n   * Attempts to go online.\n   */\n  async init({\n    room,\n    session,\n  }: {\n    room?: Room;\n    session?: Session;\n  }): Promise<{\n    doc?: T;\n  }> {\n    if (typeof window === 'undefined') {\n      return { doc: undefined };\n    }\n\n    if (!this._doc) {\n      await this.readActorIdThenCreateDoc(this._defaultDoc);\n    }\n\n    // we're offline, so we should just continue with our fun little world\n    if (!room || !session) {\n      await this.syncOfflineCache();\n      return {\n        doc: this._doc! as T,\n      };\n    }\n\n    this._roomId = room.id;\n    this._socket = Sockets.newSocket(this._socketURL + DOC_NAMESPACE, {\n      transports: ['websocket'],\n    });\n\n    this._listenerManager.on(this._socket, 'reconnect_attempt', () => {\n      invariant(this._socket);\n      this._socket.io.opts.transports = ['websocket'];\n    });\n\n    /**\n     * Errors\n     */\n    this._listenerManager.on(this._socket, 'error', (data: string) => {\n      try {\n        const { message } = JSON.parse(data);\n        console.error(`Error from Socket: ${message}`);\n      } catch (err) {\n        console.error(`Unparsable error from socket: ${data}`);\n      }\n    });\n\n    // Immediately attempt to authorize via traditional auth\n    this._authorized = authorizeSocket(this._socket, session.token, room.id);\n\n    // Required connect handler\n    this._listenerManager.on(this._socket, 'connect', () => {\n      this._peer.notify(this._doc!);\n      this.syncOfflineCache();\n    });\n\n    // Required disconnect handler\n    this._listenerManager.on(this._socket, 'disconnect', reason => {\n      if (reason === 'io server disconnect') {\n        console.warn(\n          'The RoomService client was forcibly disconnected from the server, likely due to invalid auth.'\n        );\n      }\n    });\n\n    /**\n     * We don't require these to be defined before hand since they're\n     * optional\n     */\n    if (this._onUpdateSocketCallback) {\n      this._listenerManager.on(\n        this._socket,\n        'sync_room_state',\n        this._onUpdateSocketCallback\n      );\n    }\n    if (this._onConnectSocketCallback) {\n      this._listenerManager.on(\n        this._socket,\n        'connect',\n        this._onConnectSocketCallback\n      );\n    }\n    if (this._onDisconnectSocketCallback) {\n      this._listenerManager.on(\n        this._socket,\n        'disconnect',\n        this._onDisconnectSocketCallback\n      );\n    }\n\n    // Load the document of the room.\n    const result = await fetch(\n      this._socketURL + `/client/v1/rooms/${room.id}/documents/default`,\n      {\n        headers: {\n          authorization: 'Bearer ' + session.token,\n        },\n      }\n    );\n    if (result.status !== 200) {\n      throw new Error(\n        `Unexpectedly did not find document for room ${room.reference}`\n      );\n    }\n    const roomStateStr = await result.text();\n\n    // Merge RoomService's online cache with what we have locally\n    let state;\n    try {\n      // NOTE: we purposefully don't define an actor id,\n      // since it's not assumed this state is defined by our actor.\n      state = Automerge.load(roomStateStr) as T;\n      const local = await this.syncOfflineCache();\n\n      state = merge(local, state as T);\n\n      this._doc = state;\n      this._peer.notify(this._doc);\n    } catch (err) {\n      console.error(err);\n      state = {} as T;\n    }\n\n    return { doc: state };\n  }\n\n  /**\n   * Manually go offline\n   */\n  disconnect() {\n    if (typeof window === 'undefined') {\n      console.warn(\n        'Attempting to call disconnect on the server, this is a no-op.'\n      );\n      return;\n    }\n\n    if (this._socket) {\n      Sockets.disconnect(this._socket);\n      // Remove listeners after disconnect so that\n      // disconnect listener gets called\n      this._listenerManager.removeAllListeners(this._socket);\n    }\n    this._onUpdateSocketCallback = undefined;\n    this._onConnectSocketCallback = undefined;\n    this._onDisconnectSocketCallback = undefined;\n    this._socket = undefined;\n  }\n\n  onSetDoc(callback: (state: Readonly<any>) => any) {\n    if (typeof window === 'undefined') {\n      console.warn(\n        'Attempting to call onSetDoc on the server, this is a no-op.'\n      );\n      return;\n    }\n\n    invariant(\n      !this._onUpdateSocketCallback,\n      \"It looks like you've called onSetDoc multiple times. Since this can cause quite severe performance issues if used incorrectly, we're not currently supporting this behavior. If you've got a use-case we haven't thought of, file a github issue and we may change this.\"\n    );\n\n    const socketCallback = async (data: string) => {\n      const { meta, payload } = JSON.parse(data) as RoomPacket;\n\n      if (!this._roomId) {\n        throw new Error(\n          \"Expected a _roomId to be defined before we invoked the the onSetDoc callback. This is a sign of a broken client, please contact us if you're seeing this.\"\n        );\n      }\n\n      // This socket event will fire for ALL rooms, so we need to check\n      // if this callback refers to this particular room.\n      if (meta.roomId !== this._roomId) {\n        return;\n      }\n\n      if (!payload.msg) {\n        throw new Error(\n          \"The room's state object does not include an 'msg' attribute, which could signal a corrupted room. If you're seeing this in production, that's quite bad and represents a fixable bug within the SDK itself. Please let us know and we'll fix it immediately!\"\n        );\n      }\n\n      // This is effectively impossible tbh, but we like to be cautious\n      if (!this._doc) {\n        await this.readActorIdThenCreateDoc(this._defaultDoc);\n      }\n\n      // convert the payload clock to a map\n      payload.msg.clock = Map(payload.msg.clock);\n\n      try {\n        const newDoc = this._peer.applyMessage(payload.msg, this._doc!);\n\n        // if we don't have any new changes, we don't need to do anything.\n        if (!newDoc) {\n          return;\n        }\n\n        this._doc = newDoc;\n        this._saveOffline('default', this._doc);\n\n        // From a user's perspective, the document should only update\n        // if we've actually made changes (since only we care about the\n        // clock position of everyone else).\n        if (payload.msg.changes) {\n          callback(this._doc);\n        }\n      } catch (err) {\n        // Ignore Automerge double-apply errors\n        if (\n          (err as Error).message &&\n          err.message.includes('Inconsistent reuse of sequence number')\n        ) {\n          return;\n        }\n\n        console.error(err);\n      }\n    };\n\n    // If we're offline, just wait till we're back online to assign this callback\n    if (!this._socket) {\n      this._onUpdateSocketCallback = socketCallback;\n      return;\n    }\n\n    this._listenerManager.on(this._socket, 'sync_room_state', socketCallback);\n  }\n\n  onConnect(callback: () => any) {\n    if (typeof window === 'undefined') {\n      console.warn(\n        'Attempting to call onConnect on the server, this is a no-op.'\n      );\n      return;\n    }\n\n    // If we're offline, cue this up for later.\n    if (!this._socket) {\n      this._onConnectSocketCallback = callback;\n      return;\n    }\n\n    this._listenerManager.on(this._socket, 'connect', callback);\n  }\n\n  onDisconnect(callback: () => any) {\n    if (typeof window === 'undefined') {\n      console.warn(\n        'Attempting to call onDisconnect on the server, this is a no-op.'\n      );\n      return;\n    }\n\n    // If we're offline, cue this up for later.\n    if (!this._socket) {\n      this._onDisconnectSocketCallback = callback;\n      return;\n    }\n\n    this._listenerManager.on(this._socket, 'disconnect', callback);\n  }\n\n  private async syncOfflineCache(): Promise<Doc<T>> {\n    const data = await Offline.getDoc(this._roomReference, 'default');\n    if (!data) {\n      return this._doc!;\n    }\n\n    const actorId = await Offline.getOrCreateActor();\n    if (!actorId) {\n      console.error(\n        \"Unexpectedly didn't find offline support in an environment like a browser where we should have offline support.\"\n      );\n    }\n\n    // We explictly do not add\n    const offlineDoc = load<T>(data, {\n      actorId,\n    });\n\n    this._doc = offlineDoc;\n    this._peer.notify(this._doc);\n    return offlineDoc;\n  }\n\n  // The manymerge client will call this function when it picks up changes.\n  //\n  // WARNING: This function is an arrow function specifically because\n  // it needs to access this._socket. If you use a regular function,\n  // it won't work.\n  private _sendMsgToSocket = async (automergeMsg: Message) => {\n    // we're offline, so don't do anything\n    if (!this._socket) {\n      return;\n    }\n\n    const isAuthorized = await this._authorized;\n\n    // isAuthorized is undefined if the socket disconnects before we get an answer\n    if (!this._socket || isAuthorized === undefined) {\n      return;\n    }\n\n    if (isAuthorized === false) {\n      console.error('Room Service is unable to authorize');\n      return;\n    }\n\n    invariant(\n      this._roomId,\n      \"Expected a _roomId to exist when publishing. This is a sign of a broken client, if you're seeing this, please contact us.\"\n    );\n\n    const room: RoomPacket = {\n      meta: {\n        roomId: this._roomId,\n      },\n      payload: {\n        msg: automergeMsg,\n      },\n    };\n\n    Sockets.emit(this._socket, 'sync_room_state', asRoomStr(room));\n  };\n\n  async setDoc<D>(callback: (state: D) => void): Promise<D> {\n    if (typeof window === 'undefined') {\n      console.warn('Attempting to call setDoc on the server, this is a no-op.');\n      return {} as D;\n    }\n\n    if (!this._doc) {\n      this._doc = await this.readActorIdThenCreateDoc(this._defaultDoc);\n    }\n\n    if (typeof callback !== 'function') {\n      throw new Error(`room.publishDoc expects a function.`);\n    }\n\n    let newDoc = Automerge.change(this._doc, callback);\n\n    if (!newDoc) {\n      invariant(\n        !!this._actorId,\n        \"The client is trying to regenerate a deleted document, but isn't able to access the cached actor id. This is probably a bug in the client, if you see this, we're incredibly sorry! Please let us know. In the meantime, you may be able work around this by ensuring 'await room.restore()' has finished before calling 'publishState'.\"\n      );\n\n      // this happens if someone deletes the doc, so we should just reinit it.\n      newDoc = this.createDoc(this._actorId, this._defaultDoc);\n    }\n\n    this._doc = newDoc;\n    this._saveOffline('default', newDoc);\n    this._peer.notify(newDoc);\n\n    return newDoc as D;\n  }\n\n  undo() {\n    if (this._doc && Automerge.canUndo(this._doc)) {\n      let newDoc = Automerge.undo(this._doc);\n\n      this._doc = newDoc;\n      this._saveOffline('default', newDoc);\n      this._peer.notify(newDoc);\n\n      return newDoc;\n    } else {\n      return this._doc;\n    }\n  }\n\n  redo() {\n    if (this._doc && Automerge.canRedo(this._doc)) {\n      let newDoc = Automerge.redo(this._doc);\n\n      this._doc = newDoc;\n      this._saveOffline('default', newDoc);\n      this._peer.notify(newDoc);\n\n      return newDoc;\n    } else {\n      return this._doc;\n    }\n  }\n}\n","import Sockets from './socket';\nimport { ROOM_SERICE_CLIENT_URL } from './constants';\nimport invariant from 'invariant';\nimport { Room, Session } from './types';\nimport { throttle } from 'lodash';\nimport { authorizeSocket } from './socketauth';\n\nconst PRESENCE_NAMESPACE = '/v1/presence';\n\nexport interface PresenceMeta {\n  roomId: string;\n  guest?: {\n    reference: string;\n  };\n  connectionId?: string;\n\n  // The \"key\". ex: \"cursors\", \"keyboard\", \"location\"\n  namespace: string;\n\n  // Time to live, measured in seconds. 0 means don't store\n  ttl: number;\n\n  // new Date().getTime(); measured in seconds.\n  createdAt: number;\n}\n\ninterface PresencePacket<T> {\n  meta: {\n    roomId: string;\n    guestId?: string;\n    connectionId?: string;\n\n    // The \"key\". ex: \"cursors\", \"keyboard\", \"location\"\n    namespace: string;\n\n    // Time to live, measured in seconds. 0 means don't store\n    ttl: number;\n\n    // new Date().getTime(); measured in seconds.\n    createdAt: number;\n  };\n  payload: T;\n}\n\ninterface PresenceOptions {\n  // Time to live in seconds. -1 means forever. Default is 30.\n  ttl?: number;\n}\n\nfunction isParsable(val: any) {\n  return typeof val === 'object' && val !== null;\n}\n\nconst rateLimittedEmit = throttle(\n  (\n    socket: SocketIOClient.Socket,\n    event: 'sync_room_state' | 'update_presence',\n    ...args: any[]\n  ) => Sockets.emit(socket, event, ...args),\n  40,\n  { leading: true }\n);\n\nexport default class PresenceClient {\n  // We define this as a local variable to make testing easier\n  _socketURL: string;\n  _authorizationUrl: string;\n  _roomReference: string;\n  _roomId?: string;\n  private _socket?: SocketIOClient.Socket;\n  private _authorized?: Promise<boolean | undefined>;\n\n  constructor(parameters: { authUrl: string; roomReference: string }) {\n    this._socketURL = ROOM_SERICE_CLIENT_URL;\n    this._authorizationUrl = parameters.authUrl;\n    this._roomReference = parameters.roomReference;\n  }\n\n  init({ room, session }: { room?: Room; session?: Session }) {\n    if (!room || !session) {\n      console.warn('Room Service is offline.');\n      return;\n    }\n\n    this._roomId = room.id;\n    this._socket = Sockets.newSocket(this._socketURL + PRESENCE_NAMESPACE, {\n      transports: ['websocket'],\n    });\n\n    Sockets.on(this._socket, 'reconnect_attempt', () => {\n      invariant(this._socket);\n      this._socket.io.opts.transports = ['websocket'];\n    });\n\n    // Immediately attempt to authorize via traditional auth\n    this._authorized = authorizeSocket(this._socket, session.token, room.id);\n  }\n\n  async setPresence<P>(key: string, value: P, options?: PresenceOptions) {\n    // Offline do nothing\n    if (!this._socket) {\n      return;\n    }\n    invariant(\n      this._roomId,\n      \"setPresence is missing a roomId, this is likely a bug with the client. If you're seeing this, please contact us.\"\n    );\n\n    // Ensure we're authorized before doing anything\n    if (this._authorized) {\n      await this._authorized;\n    }\n\n    const ttl = options?.ttl || 1000 * 2;\n\n    if (!value) {\n      console.error(\n        `The function call 'setPresence(\"${key}\", value)' passed in an undefined, null, or falsey 'value'.`\n      );\n      return;\n    }\n\n    if (!isParsable(value)) {\n      console.error(\n        `Expected the function call 'setPresence(\"${key}\", value)' to use a stringifiable object for variable 'value', instead got '${value}'.`\n      );\n      return;\n    }\n\n    const packet: PresencePacket<P> = {\n      meta: {\n        roomId: this._roomId,\n        createdAt: new Date().getTime(),\n        namespace: key,\n        ttl,\n      },\n      payload: value,\n    };\n\n    rateLimittedEmit(this._socket, 'update_presence', packet);\n  }\n\n  onSetPresence<P>(callback: (meta: PresenceMeta, value: P) => void) {\n    // Offline do nothing\n    if (!this._socket) {\n      console.warn('offline');\n      return;\n    }\n\n    Sockets.on(this._socket, 'update_presence', async (data: string) => {\n      const { meta, payload } = JSON.parse(data) as PresencePacket<any>;\n      if (!this._roomId) {\n        throw new Error(\n          \"Expected a _roomId to be defined before we invoked the the onSetPresence callback. This is a sign of a broken client, please contact us if you're seeing this.\"\n        );\n      }\n      if (!meta.connectionId) {\n        console.error(\n          \"Unexpectedly got a packet without a connection id. We're skipping this for now, but this could be a sign of a service outage or a broken client.\"\n        );\n      }\n\n      // Don't include self\n      if (meta.connectionId === this._socket!.id) {\n        return;\n      }\n\n      // This socket event will fire for ALL rooms that we belong\n      // to,\n      if (meta.roomId !== this._roomId) {\n        return;\n      }\n\n      callback(meta, payload);\n    });\n  }\n}\n","import DocClient from './doc-client';\nimport PresenceClient, { PresenceMeta } from './presence-client';\nimport { Obj } from './types';\nimport authorize from './authorize';\nimport { throttle } from 'lodash';\n\ninterface RoomClientParameters {\n  authUrl: string;\n  roomReference: string;\n  headers?: Headers;\n  defaultDoc?: Obj;\n}\n\nexport default class RoomClient {\n  private readonly _docClient: DocClient<Obj>;\n  private readonly _presenceClient: PresenceClient;\n  private readonly _authorizationUrl: string;\n  private readonly _roomReference: string;\n  private readonly _headers?: Headers;\n\n  constructor(parameters: RoomClientParameters) {\n    this._docClient = new DocClient(parameters);\n    this._presenceClient = new PresenceClient(parameters);\n    this._authorizationUrl = parameters.authUrl;\n    this._roomReference = parameters.roomReference;\n    this._headers = parameters.headers;\n  }\n\n  // @ts-ignore used for testing locally\n  private set _socketURL(url: string) {\n    this._docClient._socketURL = url;\n    this._presenceClient._socketURL = url;\n  }\n\n  private _init = throttle(\n    async () => {\n      let room;\n      let session;\n      try {\n        const params = await authorize(\n          this._authorizationUrl,\n          this._roomReference,\n          this._headers\n        );\n        room = params.room;\n        session = params.session;\n      } catch (err) {\n        console.error(\n          \"Room Service can't access the auth endpoint. More details: https://err.sh/getroomservice/browser/cant-access-auth-endpoint\"\n        );\n        console.warn(err);\n      }\n\n      // We're on the server, so we shouldn't init, because we don't need\n      // to connect to the clients.\n      if (typeof window === 'undefined') {\n        // This would signal that the server side can't access the auth endpoint\n        if (!room) {\n          throw new Error(\n            \"Room Service can't access the auth endpoint on the server. More details: https://err.sh/getroomservice/browser/server-side-no-network\"\n          );\n        }\n\n        return { doc: undefined };\n      }\n\n      // Presence client\n      this._presenceClient.init({\n        room,\n        session,\n      });\n\n      // Doc client\n      const { doc } = await this._docClient.init({\n        room,\n        session,\n      });\n\n      return { doc };\n    },\n    100,\n    {\n      leading: true,\n    }\n  );\n\n  // Start the client, sync from cache, and connect.\n  // This function is throttled at 100ms, since it's only\n  // supposed to be called once, but\n  async init(): Promise<Obj> {\n    return this._init();\n  }\n\n  // Manually restore from cache\n  async restore() {\n    const doc = await this._docClient.restore();\n    return doc;\n  }\n\n  // Connection\n  onConnect(callback: () => void) {\n    this._docClient.onConnect(callback);\n  }\n  onDisconnect(callback: () => void) {\n    this._docClient.onDisconnect(callback);\n  }\n  disconnect() {\n    this._docClient.disconnect();\n  }\n\n  // Documents\n  async setDoc<D extends Obj>(\n    change: (prevDoc: D) => void\n  ): Promise<Readonly<D>> {\n    return this._docClient.setDoc(change);\n  }\n  onSetDoc<D extends Obj>(callback: (newDoc: D) => void): void {\n    this._docClient.onSetDoc(callback);\n  }\n\n  undo() {\n    return this._docClient.undo();\n  }\n\n  redo() {\n    return this._docClient.redo();\n  }\n\n  // Presence\n  setPresence<P extends Obj>(key: string, value: P) {\n    this._presenceClient.setPresence(key, value);\n  }\n  onSetPresence<P extends Obj>(\n    callback: (meta: PresenceMeta, value: P) => void\n  ) {\n    this._presenceClient.onSetPresence(callback);\n  }\n}\n","import invariant from 'invariant';\nimport ky from 'ky-universal';\n\ninterface RoomValue {\n  id: string;\n  reference: string;\n}\n\nexport default async function authorize(\n  authorizationUrl: string,\n  roomReference: string,\n  headers?: Headers\n) {\n  // Generates and then records a session token\n  const result = await ky.post(authorizationUrl, {\n    json: {\n      room: {\n        reference: roomReference,\n      },\n    },\n\n    headers: headers || undefined,\n\n    // This only works on sites that have setup DNS,\n    // or the debugger on roomservice.dev/app, which\n    // uses this SDK.\n    credentials:\n      authorizationUrl.includes('https://aws.roomservice.dev') &&\n      authorizationUrl.includes('debugger-auth-endpoint')\n        ? 'include'\n        : undefined,\n    throwHttpErrors: false,\n  });\n\n  // This is just user error, so it's probably fine to throw here.\n  invariant(\n    result.status !== 405,\n    'Your authorization endpoint does not appear to accept a POST request.'\n  );\n\n  if (result.status < 200 || result.status >= 400) {\n    throw new Error(\n      `Your Auth endpoint at '${authorizationUrl}' is not functioning properly, returned status of ${result.status}.`\n    );\n  }\n\n  const res = await result.json();\n  const { room, session } = res as {\n    room: RoomValue;\n    session: { token: string };\n  };\n  return { room, session };\n}\n","import RoomClient from './room-client';\nimport { Obj } from './types';\n\nexport default class RoomServiceClient {\n  private readonly _authorizationUrl: string;\n  private readonly _headers?: Headers;\n\n  private readonly _roomPool: { [key: string]: RoomClient } = {};\n\n  constructor(parameters: { authUrl: string; headers?: Headers }) {\n    this._authorizationUrl = parameters.authUrl;\n    this._headers = parameters.headers;\n  }\n\n  room<T extends Obj>(roomReference: string, defaultDoc?: T) {\n    if (this._roomPool[roomReference]) {\n      return this._roomPool[roomReference];\n    }\n\n    const room = new RoomClient({\n      authUrl: this._authorizationUrl,\n      roomReference,\n      defaultDoc,\n      headers: this._headers,\n    });\n\n    this._roomPool[roomReference] = room;\n    return room;\n  }\n}\n"],"names":["_catch","body","recover","result","e","then","Symbol","iterator","asyncIterator","Offline","window","invariant","get","actor","id","uuid","set","console","warn","Sockets","newSocket","url","opts","IO","on","socket","event","fn","off","callback","emit","args","disconnect","ListenerManager","_listeners","push","removeAllListeners","forEach","listener","authorizeSocket","token","roomId","Promise","resolve","listenerManager","timeout","setTimeout","meta","payload","clearTimeout","DocClient","parameters","this","automergeMsg","_this","_socket","_authorized","isAuthorized","undefined","_roomId","safeJsonStringify","msg","error","_roomReference","roomReference","_defaultDoc","defaultDoc","_peer","Peer","_sendMsgToSocket","_socketURL","_listenerManager","_saveOffline","debounce","docId","doc","roomRef","value","err","_this2","save","readActorIdThenCreateDoc","state","actorId","_actorId","_this4","createDoc","_doc","Automerge","from","notify","restore","_this6","syncOfflineCache","indexedDB","init","room","session","_this8","transports","io","data","JSON","parse","message","reason","_onUpdateSocketCallback","_onConnectSocketCallback","_onDisconnectSocketCallback","fetch","headers","authorization","status","Error","reference","text","roomStateStr","load","local","merge","onSetDoc","socketCallback","clock","Map","newDoc","_this9","applyMessage","changes","includes","onConnect","onDisconnect","_this11","offlineDoc","setDoc","change","_this13","undo","canUndo","redo","canRedo","rateLimittedEmit","throttle","leading","PresenceClient","_authorizationUrl","authUrl","setPresence","key","options","ttl","val","packet","_this3","createdAt","Date","getTime","namespace","onSetPresence","connectionId","RoomClient","_presenceClient","_docClient","authorizationUrl","ky","post","json","credentials","throwHttpErrors","res","authorize","_headers","params","_init","_roomPool"],"mappings":"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"}